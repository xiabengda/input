2024-05-15
## 概述
---
比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。

>注意，比较运算符可以比较各种类型的值，不仅仅是数值。

JavaScript 一共提供了8个比较运算符。
- `>` 大于运算符
- `<` 小于运算符
- `<=` 小于或等于运算符
- `>=` 大于或等于运算符
- `==` 相等运算符
- `===` 严格相等运算符
- `!=` 不相等运算符
- `!===` 严格不相等运算符

这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。
## 非相等运算符
### 字符串的比较
字符串按照字典顺序进行比较。

JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。
```js
'cat' > 'Cat' // true
```
上面代码中，小写的`c`的 Unicode 码点（`99`）大于大写的`C`的 Unicode 码点（`67`），所以返回`true`
### 非字符串的比较
#### 1、原始类型值
如果两个运算子都是原始类型的值，则是先转成数值再比较。
```js
5 > '4' // true
// 等同于 5 > Number('4')
```

这里需要注意与`NaN`的比较。任何值（包括`NaN`本身）与`NaN`比较，返回的都是`false`。
#### 2、对象
如果运算子是对象，会转为原始类型的值，再进行比较。

对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法
```js
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'
```
## 相等运算符
### 严格相等运算符
值和数据类型必须一致才返回`true`，否则返回`false`

具体情况：

1、不同类型，直接返回false
```js
true === "true" // false
```
2、同一类型，值相同返回true，值不同返回false
```js
1 === 0x1 // true
```
注意：`NaN`与任何值都不相等（包括自身）。另外，正`0`等于负`0`。

3、复合类型值

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
```js
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
```
4、undefined和null

`undefined`和`null`与自身严格相等。
```js
undefined === undefined // true
null === null // true
```
由于变量声明后默认值是`undefined`，因此两个只声明未赋值的变量是相等的。
```js
var v1;
var v2;
v1 === v2 // true
```
### 严格非相等运算符
“严格不相等运算符”（`!==`），它的算法就是先求严格相等运算符的结果，然后返回相反值。规则同严格相等运算符
### 普通相等/非相等运算符
> 比较相同类型的数据时，比较值的大小，
```js
1 == 1.0
// 等同于
1 === 1.0
```
> 比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。

1、原始类型值：先转成数值再比较

2、对象与原始类型值比较：对象先转成原始类型的值，再进行比较

3、undefined和null：`undefined`和`null`与其他类型的值比较时，结果都为`false`，它们互相比较时结果为`true`。
> 相等运算符有一个对应的“不相等运算符”（`!=`），它的算法就是先求相等运算符的结果，然后返回相反值。



